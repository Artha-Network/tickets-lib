# ResolveTicket ed25519 signature (hex)
# Schema: escrow.v1.ResolveTicket
# Source message: canonical CBOR bytes from resolveTicket.sample.json
# Purpose: Golden signature for deterministic, cross-implementation verification.
#
# Test key material
# - Seed (hex, 32 bytes): 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
# - Derived public key must be used by verifiers for tests.
#
# How to regenerate (Node 18+, ESM):
#   node --input-type=module -e "
#     import fs from 'fs';
#     import { encode } from 'cborg';
#     import { ed25519 } from '@noble/curves/ed25519';
#
#     const seedHex =
#       '000102030405060708090a0b0c0d0e0f' +
#       '101112131415161718191a1b1c1d1e1f';
#     const seed = Uint8Array.from(Buffer.from(seedHex, 'hex'));
#
#     const obj = JSON.parse(
#       fs.readFileSync('test/vectors/resolveTicket.sample.json', 'utf8')
#     );
#     const bytes = encode(obj, { canonical: true });
#     const sig = ed25519.sign(bytes, seed);
#     console.log(Buffer.from(sig).toString('hex'));
#   "
#
# Optional: derive and print public key (store in your test config if needed):
#   node --input-type=module -e "
#     import { ed25519 } from '@noble/curves/ed25519';
#     const seedHex =
#       '000102030405060708090a0b0c0d0e0f' +
#       '101112131415161718191a1b1c1d1e1f';
#     const pk = ed25519.getPublicKey(Buffer.from(seedHex, 'hex'));
#     console.log(Buffer.from(pk).toString('hex'));
#   "
#
# Rules
# - If resolveTicket.sample.json changes, regenerate CBOR and signature.
# - Commit updates together and document in CHANGELOG.
#
# Hex (lowercase, no 0x prefix):
# PLACEHOLDER â€” regenerate with the command above and replace this line with the real hex.
